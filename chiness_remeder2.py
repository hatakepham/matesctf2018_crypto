N1 = 102901733837590507159377669565525115631193265515998810513491649266973530965320331532024679922680896660876480494498338046254771218394205724244935760332223582659476068557718158569029468073652274640472174939861146040656974442560701079600894008029477267487586747803872604509056488583935825892427227317215527053197
C1 = 29799816757025295138562761450891881343764377535992952986432180019983641935970638484816623866154225608904203474411393230733725774780595056137990734072940741844637219132628501468508477038527190282802610515191495180937881016506871559851707730711213649199480810309290255517081971537736640816618384831577120702734
N2 = 127233147747061964629618271896958327456024675884950916090747786573465383799465323004582977686581934646066330849940732070228691794193314549708664617052020959647547130369958901425948897254116054263755653479147231478513759514669684627686215141628774973197796523580388469520076801607774527548439085996892249021043
C2 = 80989166477909610939973498396615607925405602506563437992249205057412569368089074571034805490740265940880282587974373663940149216428436194268607986439150338246081997632155876460659490043731580507585612878411291636164695382385647412956736346596905642219362700546839710640145684003669075320431353276523188519004
N3 = 149118776694889845587301127493478719922029952050589502978721541615448988434232182126939742009670636513228600078585686046657715430660768671016845959095308415330380981084272039396670370231634322468601990357460276274204135761161250353136909243185026910440833444478185136426817151677832594758243336362553521808663
C3 = 49107091967234789456431086385141741626809458419261227053872218514215296883037869702625551928712211602252213737355918405422296701456142799238339794817937278824525393795190128552915412849986123910493591230951256053920685901413881966916794933210154158889056686634976130022274006297267723471982807717125724375960

import functools
import itertools

def chinese_remainder(n, a): # https://rosettacode.org/wiki/Chinese_remainder_theorem
    sum = 0
    prod = functools.reduce(lambda a, b: a*b, n)
    for n_i, a_i in zip(n, a):
        p = prod // n_i
        sum += a_i * mul_inv(p, n_i) * p
    return sum % prod
 
def mul_inv(a, b): # https://rosettacode.org/wiki/Chinese_remainder_theorem
    b0 = b
    x0, x1 = 0, 1
    if b == 1: return 1
    while a > 1:
        q = a // b
        a, b = b, a%b
        x0, x1 = x1 - q * x0, x0
    if x1 < 0: x1 += b0
    return x1

def inv_pow(c, e):
    low = -1
    high = c+1
    while low + 1 < high:
        m = (low + high) // 2
        p = pow(m, e)
        if p < c:
            low = m
        else:
            high = m
    m = high
    assert pow(m, e) ==c
    return m
 
N = [N1, N2, N3]
C = [C1, C2, C3]
e = 5
a = chinese_remainder(N, C)
for n, c in zip(N, C):
    assert a % n == c
m = inv_pow(a, e)
m = hex(m).replace('L','')
m = m[2:].decode('hex')
print m